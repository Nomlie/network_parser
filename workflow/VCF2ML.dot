digraph VCF_to_ML_Matrix_Vertical_AlignedToDataLoader {
  rankdir=TB;
  labelloc="t";
  fontsize=20;
  fontname="Helvetica,Arial,sans-serif";
  label="VCF (variant-centric) → ML feature matrix (sample-centric)\nDataLoader path: per-sample parse → cohort merge → baseline → binary encode";

  node [shape=box, style="rounded,filled", fontname="Helvetica,Arial,sans-serif", fontsize=11, penwidth=1.1];
  edge [fontname="Helvetica,Arial,sans-serif", fontsize=10, penwidth=1.2, arrowsize=0.9];

  // ───────────────────────────────────────────────
  //               INPUT
  // ───────────────────────────────────────────────
  vcf_input [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="5">
      <TR><TD COLSPAN="2"><B>Input: Folder of per-sample VCFs</B></TD></TR>
      <TR><TD>Each file</TD><TD>1 sample (called records may be ALT-only)</TD></TR>
      <TR><TD>Goal</TD><TD>Binary matrix: samples × variants (0/1)</TD></TR>
    </TABLE>
  >, fillcolor="#e8f0ff", width=3.4];

  // ───────────────────────────────────────────────
  //               PARALLEL PARSING
  // ───────────────────────────────────────────────
  parallel [label=<
    <B>Parallel parse per-sample VCFs</B><BR/>
    • n_jobs workers (joblib/parallel)<BR/>
    • stream records (no bcftools merge)<BR/>
    • output per-sample call map
  >, fillcolor="#ffd48a", shape=ellipse];

  per_vcf [label=<
    <B>iter_sample_calls()</B><BR ALIGN="LEFT"/>
    For each record:<BR ALIGN="LEFT"/>
    • is_snp_like? (single base; optional biallelic-only)<BR ALIGN="LEFT"/>
    • parse INFO<BR ALIGN="LEFT"/>
    • passes_info_qc? (QUAL / DP / MQ / MQ0F)<BR ALIGN="LEFT"/>
    • choose_called_allele() (GT-aware when possible)<BR ALIGN="LEFT"/>
    • store (chrom,pos) → (ref, called)
  >, fillcolor="#fff7db"];

  discard [label="discard record", fillcolor="#e9e9e9", fontcolor="gray35"];

  // Decision diamonds inside parse stage
  gate_snp [label="SNP-like?\n(single base; biallelic)" shape=diamond fillcolor="#fffacd"];
  gate_qc  [label="INFO QC pass?\n(QUAL/DP/MQ/MQ0F)" shape=diamond fillcolor="#fffacd"];

  // Wire parse internals (kept simple, readable)
  per_vcf -> gate_snp;
  gate_snp -> discard [label="no", style=dashed, color="#777777"];
  gate_snp -> gate_qc [label="yes"];
  gate_qc  -> discard [label="no", style=dashed, color="#777777"];

  // ───────────────────────────────────────────────
  //               COHORT MERGE + FILTERS
  // ───────────────────────────────────────────────
  cohort_merge [label=<
    <B>Cohort merge (across samples)</B><BR ALIGN="LEFT"/>
    • merge all per-sample call maps<BR ALIGN="LEFT"/>
    • count carriers only when called ≠ ref<BR ALIGN="LEFT"/>
    • (optional) enforce consistent ALT per site (biallelic-only)
  >, fillcolor="#d9f0ff"];

  presence [label=<
    <B>Cohort presence filter</B><BR/>
    keep site if carrier_count ≥ min_sample_presence
  >, fillcolor="#d9f0ff", shape=diamond];

  sort_sites [label="Sort retained sites\n(chrom, pos)", fillcolor="#d9f0ff"];

  // ───────────────────────────────────────────────
  //               BASELINE + ENCODING
  // ───────────────────────────────────────────────
  build_alleles [label=<
    <B>Build allele strings</B><BR ALIGN="LEFT"/>
    • ref_line = join REF bases (ordered sites)<BR ALIGN="LEFT"/>
    • per sample: allele_string (called else REF)<BR ALIGN="LEFT"/>
    • track per-position base counts (Counter)
  >, fillcolor="#d4f4dd"];

  baseline_choice [label=<
    <B>Choose baseline</B><BR/>
    ancestral_allele == 'Y' ? REF : MODE
  >, fillcolor="#e0ffe0", shape=diamond];

  baseline_ref [label="Baseline = REF (ref_line)", fillcolor="#e0ffe0"];
  baseline_mode [label="Baseline = MODE (majority base per site)", fillcolor="#e0ffe0"];

  encode [label=<
    <B>Binary encode</B><BR/>
    0 = matches baseline<BR/>
    1 = differs
  >, fillcolor="#cce5ff"];

  variant_ids [label=<
    <B>Variant IDs</B><BR/>
    CHROM:POS:REF:ALT
  >, fillcolor="#cce5ff"];

  // ───────────────────────────────────────────────
  //               FINAL MATRIX
  // ───────────────────────────────────────────────
  final_matrix [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="5">
      <TR><TD COLSPAN="4"><B>Final ML-ready matrix</B></TD></TR>
      <TR><TD></TD><TD><B>var1</B></TD><TD><B>var2</B></TD><TD><B>varN</B></TD></TR>
      <TR><TD><B>S1</B></TD><TD>1</TD><TD>0</TD><TD>0</TD></TR>
      <TR><TD><B>S2</B></TD><TD>0</TD><TD>1</TD><TD>1</TD></TR>
      <TR><TD><B>...</B></TD><TD>...</TD><TD>...</TD><TD>...</TD></TR>
    </TABLE>
  >, fillcolor="#e0ffe0"];

  preprocess [label=<
    <B>Light preprocessing (DataLoader only)</B><BR ALIGN="LEFT"/>
    • drop invariant cols (all 0 / all 1) [optional]<BR ALIGN="LEFT"/>
    • min_minor_count filter [optional]<BR ALIGN="LEFT"/>
    • optional compact IDs (v0, v1, …) + lookup
  >, fillcolor="#f0e8ff"];

  artifacts [label=<
    <B>Optional artifacts (if output_dir)</B><BR ALIGN="LEFT"/>
    • SNP table (minimal or annotated)<BR ALIGN="LEFT"/>
    • alleles.fasta + binary.fasta<BR ALIGN="LEFT"/>
    • filtered.tsv (+ optional context)<BR ALIGN="LEFT"/>
    • matrices/* derivatives + config snapshot
  >, fillcolor="#ffe6cc"];

  downstream [label=<
    <B>Downstream usage</B><BR/><BR/>
    • Statistical validation (χ²/Fisher + FDR)<BR/>
    • Decision tree + epistasis mining<BR/>
    • GNN / network analysis outputs
  >, fillcolor="#f0f8ff"];

  // ─── Flow ──────────────────────────────────────────────
  vcf_input    -> parallel;
  parallel     -> per_vcf [label="each sample VCF"];
  gate_qc      -> cohort_merge [label="store calls\n(per sample)"];

  cohort_merge -> presence;
  presence     -> sort_sites [label="kept"];
  sort_sites   -> build_alleles;
  build_alleles -> baseline_choice;
  baseline_choice -> baseline_ref [label="REF"];
  baseline_choice -> baseline_mode [label="MODE"];
  baseline_ref  -> encode;
  baseline_mode -> encode;
  encode       -> variant_ids -> final_matrix;
  final_matrix -> preprocess -> artifacts [style=dashed, label="if output_dir"];
  preprocess   -> downstream;

  // Layout hints
  { rank=same; vcf_input; }
  { rank=same; parallel; }
  { rank=same; per_vcf; }
  { rank=same; cohort_merge; presence; }
  { rank=same; build_alleles; baseline_choice; }
  { rank=same; final_matrix; }
}